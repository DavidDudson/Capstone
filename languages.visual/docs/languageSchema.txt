LOGIC
#####

controls_if:
    var mutation;
    var* value IF#;
    var* statement DO#;
    var* statement ELSE:

logic_compare:
    var field OP:
        EQ
        NEQ
        LT
        GT
        LTE
        GTE
    var* value A;
    var* value B;

logic_operation:
    var field OP:
        AND
        OR
    var* value A;
    var* value B;

logic_negate:
    var* value BOOL;

logic_boolean:
    var field BOOL:
        TRUE
        FALSE

LOOPS
#####

controls_repeat_ext:
    var* value TIMES;

controls_whileUntil:
    var field MODE:
        WHILE
        UNTIL
    var* value BOOL;
    var* statement DO;

controls_forEach:
    var field VAR;
    var* value LIST;
    var* statement DO;

controls_for:
    var field VAR;
    var* value FROM;
    var* value TO;
    var* value BY;
    var* value DO;

controls_flow_statements:   // must be used in loop
    var field FLOW:
        BREAK
        CONTINUE

MATH
####

math_number:
    var field NUM;

math_arithmetic:
    var field OP:
        ADD
        MINUS
        MULTIPLY
        DIVIDE
        POWER
    var* value A;
    var* value B;

math_single:
    var field OP:
        ROOT
        ABS
        NEG
        LN
        LOG10
        EXP
        POW10
    var* value NUM;

math_trig:
    var field OP:
        SIN
        COS
        TAN
        ASIN
        ACOS
        ATAN
    var* value NUM;

math_number_property:
    var mutation;
    var field PROPERTY:
        EVEN
        ODD
        PRIME
        WHOLE
        POSITIVE
        NEGATIVE
        DIVISIBLE_BY
    var* value NUMBER_TO_CHECK;
    var* value DIVISOR;     //only present if PROPERTY == DIVISIBLE_BY

math_change:
    var field VAR;
    var* value DELTA;

math_round:
    var field OP:
        ROUND
        ROUNDUP
        ROUNDDOWN
    var* value NUM;

math_on_list:
    var field OP:
        SUM
        MIN
        MAX
        AVERAGE
        MEDIAN
        MODE
        STD_DEV
        RANDOM
    var* value LIST;

math_modulo:
    var* value DIVIDEND;
    var* value DIVISOR;

math_constrain:
    var* value VALUE;
    var* value LOW;
    var* value HIGH;

math_random_int:
    var* value FROM;
    var* value TO;

math_random_float;

LISTS
#####

lists_create_empty;

lists_create_with:
    var mutation;
    var* value ADD#;

lists_repeat:
    var* value ITEM;
    var* value NUM;

lists_length:
    var* value VALUE;

lists_isEmpty:
    var* value VALUE;

lists_indexOf:
    var field END:
        FIRST
        LAST
    var* value VALUE;
    var* value FIND;

lists_getIndex:
    var mutation;
    var field MODE:
        GET
        GET_REMOVE
        REMOVE
    var field WHERE:
        FROM_START
        FROM_END
        FIRST
        LAST
        RANDOM
    var* value VALUE;
    var* value AT;  // only present if WHERE == FROM_START or WHERE == FROM_END

lists_setIndex:
    var mutation;
    var field MODE:
        SET
        INSERT
    var field WHERE:
        FROM_START
        FROM_END
        FIRST
        LAST
        RANDOM
    var* value LIST;
    var* value AT;
    var* value TO;

lists_getSublist:
    var mutation;
    var field WHERE1:
        FROM_START
        FROM_END
        FIRST
    var field WHERE2:
        FROM_START
        FROM_END
        LAST
    var* value LIST;
    var* value AT1;     // only present if WHERE1 != FIRST
    var* value AT2;     // only present if WHERE2 != LAST

VARIABLES
#########

variables_set:
    var field VAR;
    var* value VALUE;

variables_get:
    var field VAR;

FUNCTIONS
#########

procedures_defnoreturn:
    var mutation;
    var field NAME;
    var* statement STACK;

procedures_defreturn:
    var mutation;
    var field NAME;
    var* statement STACK;
    var* value RETURN;

procedures_ifreturn:        // must be used in function
    var mutation;   // can ignore???
    var* value CONDITION;
    var* value VALUE;

procedures_callnoreturn:    // only visible if function has been created
    var mutation;   // contains name of function

procedures_callreturn:      // only visible if function has been created
    var mutation;   // contains name of function