\section{Security}


As mentioned before, the security of any system that allows the execution of code submitted from an open web-client on the server is critical. We briefly describe the main challenges, and how they are addressed. 

\subsection{Usage of critical system functionality}
\label{ssec:whitelist}

Bots should not have access to parts of the platform API that would allow them to create or manipulate critical resources. In particular, this includes access to I/O classes, \texttt{java.lang.System} and the threading API. This is enforced via API white lists during the static analysis steps in the build process. If access to APIs not on the white list is detected, a descriptive error is sent back to the client. On the client, a marker pointing to the respective source code and displaying the error message is generated.  


\subsection{Responsiveness to Timeouts}
\label{ssec:timeouts}

For performance as well as for security reasons, bots are executed in (pooled) threads using the Java executor framework. This allows some thread-based sandboxing. In particularly, long-running tasks can be interrupted, and therefore certain types of denial-of-service attacks can be prevented.

When a task is submitted, a timeout can be set that will interrupt a task that runs too long. However, since the Java threading model is collaborative \cite{goetz2006java}, a task cannot be directly terminated. Instead, the collaboration of a task is required to self-terminate. Since students cannot be expected to support this in their code by frequently consulting the interrupted state and terminating computation when it is set to true, the code for these checks must be transparently injected. This is done during the instrumentation phase of the build process.  

\subsection{Memory Allocation Quota}

The injection-based monitoring described above can also be used to enforce memory allocation limits. For each method invocation in bot code, a call to a monitoring interface is injected. With this monitor, method invocation quota can be enforced, and therefore stack overflow errors can be prevented. We can also control the heap memory allocated from the current thread at this point \footnote{Note that this requires the presence of the \texttt{com.sun.management.ThreadMXBean} MBean that is available in Oracles JDK, but not in the OpenJDK as of version 8u40}, and force the bots to terminate if a certain quota is exceeded.
\label{ssec:heapquota}

\subsection{Security for Python User Code}
\label{ssec:jythoninstrumentation}

Unfortunately, the approach described in sections \ref{ssec:timeouts} and \ref{ssec:heapquota} can not be easily ported to Jython (i.e., Python on the JVM). For Jython, we have used the built-in Jython debugger utility to wrap and execute Python code. The debugger can then make the equivalent calls to the monitoring interface that checks the interrupted state and the heap memory allocation. 