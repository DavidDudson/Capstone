\section{Design}

\subsection{Requirements}


The design of SoGaCo is based on the following requirements elicited from interviews with teachers.

\begin{itemize}
	
\item[REQ1] Programming Language Support. There have been significant changes in the use of programming languages for highschool and entry-level undergraduate computer science courses in recent years, with Python and Java being the most widely used languages at the moment \cite{guo2014python}. It is very likely that there will be more changes. Therefore, our platform is to support multiple languages.

\item[REQ2] Cloud deployability. Cloud-based deployment is necessary to build and deliver a platform that provides low total cost of ownership for users. In particular, with this approach on-site installation can be avoided.

\item[REQ3] Security. Web-based deployment means that code is submitted to the server for compilation and execution. This makes the system extremely vulnerable to injection attacks, including ``unintentional'' attacks caused by careless programming. This must be addressed.

\item[REQ4] Multiple Games. It cannot be expected that a single game can satisfy the needs of different courses and student cohorts with diverse educational and cultural backgrounds. Therefore, the platform must be separated from the actual content (the games).

\item[REQ5] Authentication. Whenever possible, providers should not have the responsibility to manage user account information. Instead, existing user accounts (in-house or social) should be re-used.

\end{itemize}


\subsection{Abstractions}


The design of the system has to address the requirements discussed above. At the core of the design are some abstractions that describe services or subsystems. While implementations of these abstractions are necessary to deploy an actual instance of SoGaCo, there is a significant amount of freedom how these abstractions are provided.

One of the main design decisions was to use the Java Virtual Machine (JVM) \cite{lindholm2014java} as a platform. The JVM itself provides core abstractions, for instance the ability to execute code written in different languages (REQ1), including explicit support for Java and Python. The JVM with its ecosystem of high quality low cost application servers is also a good platform for cloud-based deployment (REQ2), and libraries like Shiro provide the abstractions for third-party in-house (LDAP) and social (OpenAuth) authentication (REQ5). 

\subsection{Services}

The system is designed around a set of HTTP services following the REST approach \cite{fielding2000architectural}. Data transferred between client and server is generally JSON-encoded. State is avoided whenever possible, however, HTTP sessions are used to track user information such as authentication status. This is imposed by the Shiro framework\footnote{\url{http://shiro.apache.org/}} used to provide authentication services. This design supports the implementation of alternative clients, such as mobile applications. Core services are listed in Table \ref{tab:services}.


\begin{table}[!h]
	\centering
	\caption{Core Services}
	\label{tab:services}
	\begin{tabular}{p{2.6cm}p{0.8cm}p{3.9cm}}
		\hline
		URL Pattern & Method & Description \\
		\hline
		\texttt{/bots/}	 & POST & build and save a new bot\\
		
		\texttt{/bots/\textless botId\textgreater}   & PUT  & build and save an existing bot\\
				
		\texttt{/delete/\-\textless botId\textgreater  } & DELETE  & delete a bot \\ 
		
		\texttt{/bots-src/ \textless botId\textgreater} & GET  & fetch the source code of a bot\\
				
		\texttt{/bot-metadata/ \textless botId\textgreater} & GET & fetch the meta data for a bot \\
		
		\texttt{/userbots/ \textless userId\textgreater} & GET  & get the bot ids of the bots owned by a user  \\
				
		\texttt{/creategame\_b2b}  & POST  & create a bot against bot game\\
		
		\texttt{/games/\textless gameId\textgreater} & GET & fetch a recorded game \\
		
		\texttt{/template/ \textless language\textgreater}   & GET  & get the bot code template for the respective language \\   
		\hline                                                                  
	\end{tabular}
\end{table}



\subsection{Build Process}


At the core of SoGaCo is a builder. The purpose of the builder is to turn source code into bot objects that can participate in games, while enforcing a strict security regime and giving detailed feedback to users when the build process fails.
Providing support for multiple languages while addressing the unique security issues of cloud-based systems is non-trivial. Java code can be compiled programmatically through the Java Compiler interface \texttt{javax.tools.JavaCompiler}. However, code written in many other languages can only be interpreted, either via proprietary interfaces or via the JSR223 \cite{grogan2006jsr} standard interface. The build process we devised consists of a number of operations that are performed sequentially.


For compiled languages like Java, the following steps are performed.



\begin{itemize}

\item[COMPILE] Source code is compiled into byte code using the respective language compiler.

\item[BYTE\_CHECK] The generated byte code is checked for violations of security rules. Checks are performed on a byte code model generated with ASM \cite{bruneton2002asm}.

\item[BYTE\_INSTR] The generated byte code is instrumented. Code to monitor bots for resource usage, to react to timeout requests and to generate trace statements is injected.

\item[LOADING] The byte code is used to load a Java class. 

\item[INSTANTIATION] The class is instantiated.

\item[TESTING] A JUnit \cite{beck1998test} acceptance test suite is executed to check the semantics and the quality of service characteristics of the bot. In particular, the correctness of generated game moves (post conditions) and resource allocation (timeouts, memory usage) are tested. A custom JUnit runner that allows to inject the object under test is used. 

\end{itemize}


For interpreted languages like Python, the following steps are performed:

\begin{itemize}

\item[SRC\_CHECK] Source code is checked for violations of security rules. Usually, source code is parsed into an abstract syntax tree to perform this step.

\item[SRC\_INSTR] Source code is instrumented. Code to monitor bots for resource usage, enforce timeouts and generate trace statements is injected. Usually, source code is parsed into an abstract syntax tree to perform this step.

\item[INSTANTIATION] A Java wrapper object is created. Internally, this object uses the interpreter and the submitted source code to interpret method invocations during game play.

\item[TESTING] A JUnit acceptance test suite is executed to check
the bot. See above for details.

\end{itemize}


